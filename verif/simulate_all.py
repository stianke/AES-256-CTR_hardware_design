
import subprocess
import os
import shutil
import time
import datetime

def main():

    # Get path to this script
    calling_path = os.path.dirname(__file__)

    # Get path to the vivado installation
    vivado_path = 'C:/Xilinx/2025.1/Vivado/bin/vivado.bat'
    
    # Get relative paths to the project files and helper script
    tcl_script_path = f'{calling_path}/simulation_helper_script/run_simulation.tcl'
    project_dir = f'{calling_path}/../vivado_project'
    xsim_folder = f'{project_dir}/AES_256_CTR.sim/sim_1/behav/xsim'
    project_path = f'{project_dir}/AES_256_CTR.xpr'

    # Read how many key/IV pairs are tested, and how many tests are performed per pair
    num_test_sets = 0
    num_block_per_set = 0
    with open(f'{calling_path}/generated_test_data/number_of_test_sets.txt', 'r') as file:
        num_test_sets = file.readline().strip()
    with open(f'{calling_path}/generated_test_data/t_000_plaintext.txt', 'r') as file:
         num_block_per_set = sum(1 for line in file)

    # Delete old simulation results
    results_dir_top = f'{calling_path}/simulation_results'
    if os.path.isdir(results_dir_top):
        shutil.rmtree(results_dir_top)
    os.mkdir(results_dir_top)
    
    start_time = time.time()

    # Create file for writing results to
    results_summary_filename = f'{results_dir_top}/summary.txt'
    with open(results_summary_filename, 'w') as summary_file:
        summary_file.write(f'\nStarting multi-simulation run at time {datetime.datetime.now().strftime("%H:%M:%S %d/%m/%Y")}\n\n')
        summary_file.write(f'Each configuration is tested with {num_test_sets} key/IV pairs, and {num_block_per_set} blocks are encrypted with each key/IV pair\n\n')

    keystream_buffer_size_value = [ 0, 3, 10 ]
    iv_counter_width_values = [ 32, 64 ]
    num_aes_core_values  = [ 1, 2, 3, 4, 5, 8, 15 ]

    print('Starting simulation script')

    for iv_counter_width in iv_counter_width_values:
        for keystream_buffer_size in keystream_buffer_size_value:
            

            # Print the counter width and keystream buffer size
            with open(results_summary_filename, 'a') as summary_file:
                summary_file.write(f'\n\n\n\n')
                summary_file.write(f'*****************************************************************\n')
                summary_file.write(f'*****************************************************************\n')
                summary_file.write(f'                     Counter Width: {iv_counter_width} bits\n')
                summary_file.write(f'                Keystream Buffer size: {keystream_buffer_size} blocks\n')
                summary_file.write(f'*****************************************************************\n')
                summary_file.write(f'*****************************************************************\n')

            for num_aes_cores in num_aes_core_values:
                print (f'Running simulation script with {iv_counter_width} Counter width, {keystream_buffer_size} keystream buffer size and {num_aes_cores} AES Cores')
                with open(results_summary_filename, 'a') as summary_file:
                    summary_file.write(f'\nSimulation results with {num_aes_cores} AES Cores:\n')
                
                print('Deleting old xsim results')
                while os.path.isdir(xsim_folder):
                    try:
                        # Delete with system command, since os.remove() fails with permission error (vivado forgets to unlock glbl.v)
                        cmnd_txt = f'cmd.exe /c rmdir /s /q "{xsim_folder}/"'
                        subprocess.call(cmnd_txt, shell=True)
                    except Exception  as e:
                        print(f"An error occurred: {e}")
                        print('Failed to delete. Sleeping 1 second and retrying...')
                        time.sleep(1)



                command = f'{vivado_path} -mode batch -source {tcl_script_path} -tclargs {num_aes_cores} {keystream_buffer_size} {iv_counter_width} {project_dir} {xsim_folder} {project_path}'

                os.chdir(f'{calling_path}/simulation_helper_script')
                if not os.path.isdir('autogenerated_trash'):
                    os.mkdir('autogenerated_trash')
                os.chdir('autogenerated_trash')

                print('Running simulation')
                res = subprocess.check_output(command)

                

                simulation_run_directory = f'{results_dir_top}/{keystream_buffer_size}_keystr_buff_size__{iv_counter_width}_counter_width__{num_aes_cores}_cores'
                sim_log = f'{simulation_run_directory}/simulate.log'

                # Create folder for simulation results
                print('Creating folder for simulation results')
                if not os.path.isdir(simulation_run_directory):
                    os.mkdir(simulation_run_directory)


                # Fetch simulation results
                print('Fetching simulation results')
                shutil.copy(f'{xsim_folder}/simulate.log', sim_log)
                
                print('Extracting relevant lines to summary file')
                with open(sim_log, 'r') as sim_log_file:
                    with open(results_summary_filename, 'a') as summary_file:
                        for line in sim_log_file:
                            if 'Simulation started with generics' in line or \
                               'Failed' in line or \
                               'shows an average throughput of one block encrypted' in line or\
                               'Simulation finished successfully' in line:
                               summary_file.write('\t' + line)
                print('')


    # Calculate and print combined execution time
    endt_time = time.time()
    elapsed_time = endt_time - start_time
    minutes = int(elapsed_time / 60)
    seconds = elapsed_time % 60
    print(f'\n\n\nAll simulation completed in {minutes} min {seconds} sec\n')
    with open(results_summary_filename, 'a') as summary_file:
        summary_file.write(f'\n\n\nAll simulations completed in {minutes} min {seconds} sec')



if __name__ == '__main__':
    main()